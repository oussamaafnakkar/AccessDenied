#!/usr/bin/env python3
"""
Vault Challenge v2 - Stage 2: RC4 Decryption
Decrypt the inner RC4 layer from the flag

Usage: python3 decrypt_rc4.py

This script demonstrates Stage 2 of the multi-stage decryption process.
After XOR decryption, use this to decrypt the RC4 layer.

RC4 Algorithm:
- Key Scheduling Algorithm (KSA): Initialize S-box with key
- Pseudo-Random Generation Algorithm (PRGA): Generate keystream and XOR

Author: Oussama Afnakkar - Secure Byte Chronicles
"""

import struct

# ============================================================================
# CONFIGURATION
# ============================================================================

FIXED_HWID = 0xABCD1234
FIXED_USERNAME = "CTFPlayer"
FIXED_TIMESTAMP = 0x65432100
MAGIC_1 = 0xDEADBEEF
MAGIC_2 = 0x13371337

# XOR-decrypted data (output from decrypt_xor.py)
# This should be filled with the result from Stage 1
XOR_DECRYPTED_DATA = bytes([
    # Placeholder - replace with actual XOR-decrypted bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
])

# ============================================================================
# KEY DERIVATION
# ============================================================================

def djb2_hash(s):
    """DJB2 hash algorithm"""
    hash_value = 5381
    for c in s:
        hash_value = ((hash_value << 5) + hash_value) + ord(c)
        hash_value &= 0xFFFFFFFF
    return hash_value


def derive_rc4_key():
    """
    Derive the 16-byte RC4 key from XOR key
    
    The RC4 key is generated by taking bytes from the XOR key:
    rc4_key[i] = (xor_key >> ((i % 4) * 8)) & 0xFF
    """
    # First derive XOR key
    hwid = FIXED_HWID
    username_hash = djb2_hash(FIXED_USERNAME)
    timestamp = FIXED_TIMESTAMP
    
    stage1 = hwid ^ MAGIC_1
    stage2 = username_hash ^ timestamp
    xor_key = (stage1 + stage2) ^ MAGIC_2
    xor_key &= 0xFFFFFFFF
    
    # Generate 16-byte RC4 key from XOR key
    rc4_key = bytearray()
    for i in range(16):
        byte = (xor_key >> ((i % 4) * 8)) & 0xFF
        rc4_key.append(byte)
    
    return bytes(rc4_key), xor_key


# ============================================================================
# RC4 IMPLEMENTATION
# ============================================================================

def rc4_init(key):
    """
    RC4 Key Scheduling Algorithm (KSA)
    
    Initializes the S-box (permutation of 0-255) based on the key.
    This is the first phase of RC4.
    """
    S = list(range(256))  # S-box: [0, 1, 2, ..., 255]
    j = 0
    keylen = len(key)
    
    # Permute S-box based on key
    for i in range(256):
        j = (j + S[i] + key[i % keylen]) % 256
        # Swap S[i] and S[j]
        S[i], S[j] = S[j], S[i]
    
    return S


def rc4_crypt(S, data):
    """
    RC4 Pseudo-Random Generation Algorithm (PRGA)
    
    Generates a keystream and XORs it with the data.
    This is the second phase of RC4.
    
    Note: RC4 is symmetric - encryption and decryption are identical.
    """
    S = S.copy()  # Don't modify original S-box
    decrypted = bytearray()
    i = j = 0
    
    for byte in data:
        # Generate next keystream byte
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        
        # Swap S[i] and S[j]
        S[i], S[j] = S[j], S[i]
        
        # Keystream byte
        K = S[(S[i] + S[j]) % 256]
        
        # XOR with data
        decrypted.append(byte ^ K)
    
    return bytes(decrypted)


# ============================================================================
# VISUALIZATION
# ============================================================================

def visualize_rc4(key, data):
    """Show RC4 algorithm step-by-step (first 10 bytes)"""
    print("[*] RC4 Algorithm Visualization (first 10 bytes):")
    print()
    
    S = rc4_init(key)
    i = j = 0
    
    print("    Step | i | j | S[i] | S[j] | K | Data | Output")
    print("    " + "-" * 54)
    
    for step, byte in enumerate(data[:10]):
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        output = byte ^ K
        
        print(f"    {step:4d} | {i:3d} | {j:3d} | {S[i]:4d} | {S[j]:4d} | "
              f"{K:3d} | {byte:4d} | {output:4d} ('{chr(output) if 32 <= output < 127 else '?'}')")
    
    print("    ...")
    print()


# ============================================================================
# MAIN
# ============================================================================

def main():
    print("=" * 70)
    print("  VAULT CHALLENGE v2 - STAGE 2: RC4 DECRYPTION")
    print("  Secure Byte Chronicles")
    print("=" * 70)
    print()
    
    print("[*] Deriving RC4 key...")
    rc4_key, xor_key = derive_rc4_key()
    
    print(f"    XOR Key: 0x{xor_key:08X}")
    print(f"    RC4 Key (16 bytes): {rc4_key.hex()}")
    print()
    
    print("[*] RC4 Key Derivation:")
    print("    The 16-byte RC4 key is derived by repeating the XOR key bytes:")
    for i in range(16):
        byte_value = (xor_key >> ((i % 4) * 8)) & 0xFF
        print(f"      rc4_key[{i:2d}] = (xor_key >> {(i % 4) * 8:2d}) & 0xFF = 0x{byte_value:02x}")
    print()
    
    # Check if we have actual data
    if XOR_DECRYPTED_DATA == bytes(len(XOR_DECRYPTED_DATA)):
        print("[!] No XOR-decrypted data loaded")
        print("[!] Run decrypt_xor.py first to get Stage 1 output")
        print()
        return
    
    print("[*] Initializing RC4 S-box (KSA)...")
    S = rc4_init(rc4_key)
    print(f"    S-box first 16 values: {S[:16]}")
    print(f"    S-box last 16 values:  {S[-16:]}")
    print()
    
    # Visualize algorithm
    visualize_rc4(rc4_key, XOR_DECRYPTED_DATA)
    
    print("[*] Decrypting with RC4 (PRGA)...")
    rc4_decrypted = rc4_crypt(S, XOR_DECRYPTED_DATA)
    
    print(f"    RC4-Encrypted: {XOR_DECRYPTED_DATA[:16].hex()}...")
    print(f"    RC4-Decrypted: {rc4_decrypted[:16].hex()}...")
    print()
    
    # Try to decode
    try:
        flag = rc4_decrypted.decode('ascii').rstrip('\x00')
        print("=" * 70)
        print("  DECRYPTION COMPLETE")
        print("=" * 70)
        print()
        print(f"  FLAG: {flag}")
        print()
        
        # Verify flag format
        if flag.startswith('SBC{') and flag.endswith('}'):
            print("[+] ✓ Valid flag format!")
            print("[+] ✓ Challenge solved!")
        else:
            print("[!] Flag format unexpected")
            print("[!] Expected: SBC{...}")
    except UnicodeDecodeError:
        print("[!] RC4 decryption produced non-ASCII data")
        print("[!] Possible issues:")
        print("    - Wrong RC4 key derivation")
        print("    - Incorrect XOR-decrypted input")
        print("    - Key derivation algorithm changed")
        print()
        print(f"Decrypted bytes: {rc4_decrypted.hex()}")
    
    print()
    print("=" * 70)
    print("  RC4 ALGORITHM SUMMARY")
    print("=" * 70)
    print()
    print("RC4 is a stream cipher consisting of two phases:")
    print()
    print("1. KSA (Key Scheduling Algorithm):")
    print("   - Initialize S-box as [0,1,2,...,255]")
    print("   - Permute based on key")
    print("   - Creates initial state")
    print()
    print("2. PRGA (Pseudo-Random Generation Algorithm):")
    print("   - Generate keystream bytes from S-box")
    print("   - XOR keystream with data")
    print("   - Encryption = Decryption (symmetric)")
    print()
    print("Why RC4 is weak (but still used in malware):")
    print("  • Known biases in keystream")
    print("  • Related-key attacks")
    print("  • Deprecated in TLS/WEP")
    print("  • Still fast and simple to implement")
    print()


if __name__ == "__main__":
    main()
