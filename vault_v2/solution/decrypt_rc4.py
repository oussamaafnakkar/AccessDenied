#!/usr/bin/env python3
"""
Vault Challenge v2 - Stage 2: RC4 Decryption
Decrypt the inner RC4 layer from the flag

Usage: python3 decrypt_rc4.py

This script demonstrates Stage 2 of the multi-stage decryption process.
After XOR decryption, use this to decrypt the RC4 layer.

RC4 Algorithm:
- Key Scheduling Algorithm (KSA): Initialize S-box with key
- Pseudo-Random Generation Algorithm (PRGA): Generate keystream and XOR

Author: Oussama Afnakkar - Secure Byte Chronicles
"""

import struct

# ============================================================================
# CONFIGURATION
# ============================================================================

FIXED_HWID = 0xABCD1234
FIXED_USERNAME = "CTFPlayer"
FIXED_TIMESTAMP = 0x65432100
MAGIC_1 = 0xDEADBEEF
MAGIC_2 = 0x13371337

# Encrypted flag (from vault_v2.c)
ENCRYPTED_FLAG = bytes([
    0xad, 0x61, 0xbf, 0x75, 0xe1, 0x91, 0x32, 0x41,
    0x79, 0xdb, 0x35, 0xac, 0x78, 0x7a, 0x10, 0x22,
    0xe1, 0xec, 0x2f, 0x2c, 0x32, 0xf8, 0x14, 0x36,
    0x34, 0x78, 0x62, 0x1e, 0xbd, 0x18, 0xa5, 0x10,
    0x28, 0x7c
])

# ============================================================================
# KEY DERIVATION
# ============================================================================

def djb2_hash(s):
    """DJB2 hash algorithm"""
    hash_value = 5381
    for c in s:
        hash_value = ((hash_value << 5) + hash_value) + ord(c)
        hash_value &= 0xFFFFFFFF
    return hash_value


def derive_rc4_key():
    """
    Derive the 16-byte RC4 key from XOR key
    
    The RC4 key is generated by taking bytes from the XOR key:
    rc4_key[i] = (xor_key >> ((i % 4) * 8)) & 0xFF
    """
    # First derive XOR key
    hwid = FIXED_HWID
    username_hash = djb2_hash(FIXED_USERNAME)
    timestamp = FIXED_TIMESTAMP
    
    stage1 = hwid ^ MAGIC_1
    stage2 = username_hash ^ timestamp
    xor_key = (stage1 + stage2) ^ MAGIC_2
    xor_key &= 0xFFFFFFFF
    
    # Generate 16-byte RC4 key from XOR key
    rc4_key = bytearray()
    for i in range(16):
        byte = (xor_key >> ((i % 4) * 8)) & 0xFF
        rc4_key.append(byte)
    
    return bytes(rc4_key), xor_key


def xor_decrypt(data, key):
    """XOR decrypt with 4-byte rotating key (Stage 1)"""
    key_bytes = struct.pack('<I', key)
    decrypted = bytearray()
    
    for i, byte in enumerate(data):
        decrypted.append(byte ^ key_bytes[i % 4])
    
    return bytes(decrypted)


# ============================================================================
# RC4 IMPLEMENTATION
# ============================================================================

def rc4_init(key):
    """
    RC4 Key Scheduling Algorithm (KSA)
    
    Initializes the S-box (permutation of 0-255) based on the key.
    This is the first phase of RC4.
    """
    S = list(range(256))  # S-box: [0, 1, 2, ..., 255]
    j = 0
    keylen = len(key)
    
    # Permute S-box based on key
    for i in range(256):
        j = (j + S[i] + key[i % keylen]) % 256
        # Swap S[i] and S[j]
        S[i], S[j] = S[j], S[i]
    
    return S


def rc4_crypt(S, data):
    """
    RC4 Pseudo-Random Generation Algorithm (PRGA)
    
    Generates a keystream and XORs it with the data.
    This is the second phase of RC4.
    
    Note: RC4 is symmetric - encryption and decryption are identical.
    """
    S = S.copy()  # Don't modify original S-box
    decrypted = bytearray()
    i = j = 0
    
    for byte in data:
        # Generate next keystream byte
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        
        # Swap S[i] and S[j]
        S[i], S[j] = S[j], S[i]
        
        # Keystream byte
        K = S[(S[i] + S[j]) % 256]
        
        # XOR with data
        decrypted.append(byte ^ K)
    
    return bytes(decrypted)


# ============================================================================
# VISUALIZATION
# ============================================================================

def visualize_rc4(key, data):
    """Show RC4 algorithm step-by-step (first 10 bytes)"""
    print("[*] RC4 Algorithm Visualization (first 10 bytes):")
    print()
    
    S = rc4_init(key)
    i = j = 0
    
    print("    Step | i | j | S[i] | S[j] | K | Data | Output | ASCII")
    print("    " + "-" * 64)
    
    for step, byte in enumerate(data[:10]):
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        output = byte ^ K
        ascii_char = chr(output) if 32 <= output < 127 else '?'
        
        print(f"    {step:4d} | {i:3d} | {j:3d} | {S[i]:4d} | {S[j]:4d} | "
              f"{K:3d} | {byte:4d} | {output:4d} | '{ascii_char}'")
    
    print("    ...")
    print()


# ============================================================================
# MAIN
# ============================================================================

def main():
    print("=" * 70)
    print("  VAULT CHALLENGE v2 - STAGE 2: RC4 DECRYPTION")
    print("  Secure Byte Chronicles")
    print("=" * 70)
    print()
    
    print("[*] Deriving RC4 key...")
    rc4_key, xor_key = derive_rc4_key()
    
    print(f"    XOR Key: 0x{xor_key:08X}")
    print(f"    RC4 Key (16 bytes): {rc4_key.hex()}")
    print()
    
    print("[*] RC4 Key Derivation:")
    print("    The 16-byte RC4 key is derived by repeating the XOR key bytes:")
    for i in range(16):
        byte_value = (xor_key >> ((i % 4) * 8)) & 0xFF
        print(f"      rc4_key[{i:2d}] = (xor_key >> {(i % 4) * 8:2d}) & 0xFF = 0x{byte_value:02x}")
    print()
    
    # Perform Stage 1 decryption first
    print("[*] Stage 1: XOR Decryption...")
    xor_decrypted = xor_decrypt(ENCRYPTED_FLAG, xor_key)
    print(f"    XOR-Encrypted:  {ENCRYPTED_FLAG[:16].hex()}...")
    print(f"    XOR-Decrypted:  {xor_decrypted[:16].hex()}...")
    print()
    
    print("[*] Stage 2: RC4 Decryption")
    print()
    
    print("[*] Initializing RC4 S-box (KSA)...")
    S = rc4_init(rc4_key)
    print(f"    S-box first 16 values: {S[:16]}")
    print(f"    S-box last 16 values:  {S[-16:]}")
    print()
    
    # Visualize algorithm
    visualize_rc4(rc4_key, xor_decrypted)
    
    print("[*] Decrypting with RC4 (PRGA)...")
    rc4_decrypted = rc4_crypt(S, xor_decrypted)
    
    print(f"    RC4-Encrypted: {xor_decrypted[:16].hex()}...")
    print(f"    RC4-Decrypted: {rc4_decrypted[:16].hex()}...")
    print()
    
    # Try to decode
    try:
        flag = rc4_decrypted.decode('ascii').rstrip('\x00')
        print("=" * 70)
        print("  DECRYPTION COMPLETE")
        print("=" * 70)
        print()
        print(f"  FLAG: {flag}")
        print()
        
        # Verify flag format
        if flag.startswith('SBC{') and flag.endswith('}'):
            print("[+] ✓ Valid flag format!")
            print("[+] ✓ Challenge solved!")
            print()
            
            # Extract and display session ID
            if '_v2}' in flag:
                parts = flag[4:-1].split('_')  # Remove SBC{ and }
                if len(parts) >= 3:
                    session_id = parts[-2]  # Second to last part
                    print(f"[*] Session ID: {session_id}")
                    print(f"    Calculation: 0x{FIXED_TIMESTAMP:08X} ⊕ 0x12345678 = 0x{session_id}")
        else:
            print("[!] Flag format unexpected")
            print("[!] Expected: SBC{d3crypt3d_53ss10n_<session_id>_v2}")
    except UnicodeDecodeError:
        print("[!] RC4 decryption produced non-ASCII data")
        print("[!] Possible issues:")
        print("    - Wrong RC4 key derivation")
        print("    - Incorrect XOR-decrypted input")
        print("    - Key derivation algorithm mismatch")
        print()
        print(f"Decrypted bytes: {rc4_decrypted.hex()}")
    
    print()
    print("=" * 70)
    print("  RC4 ALGORITHM SUMMARY")
    print("=" * 70)
    print()
    print("RC4 is a stream cipher consisting of two phases:")
    print()
    print("1. KSA (Key Scheduling Algorithm):")
    print("   - Initialize S-box as [0,1,2,...,255]")
    print("   - Permute based on key")
    print("   - Creates initial state")
    print()
    print("2. PRGA (Pseudo-Random Generation Algorithm):")
    print("   - Generate keystream bytes from S-box")
    print("   - XOR keystream with data")
    print("   - Encryption = Decryption (symmetric)")
    print()
    print("Why RC4 is weak (but still used in malware):")
    print("  • Known biases in keystream")
    print("  • Related-key attacks")
    print("  • Deprecated in TLS/WEP")
    print("  • Still fast and simple to implement")
    print()
    print("Real malware uses stronger crypto:")
    print("  • AES-256 (symmetric encryption)")
    print("  • RSA-4096 (key protection)")
    print("  • ChaCha20 (modern stream cipher)")
    print()


if __name__ == "__main__":
    main()
